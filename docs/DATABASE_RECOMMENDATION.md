# 数据库选择建议

## 当前数据特点分析

### 数据量估算
- **板块信息历史**: 90条/天 × 250交易日 = 22,500条/年
- **涨停股票池**: 80条/天 × 250交易日 = 20,000条/年
- **炸板股票池**: 25条/天 × 250交易日 = 6,250条/年
- **跌停股票池**: 5条/天 × 250交易日 = 1,250条/年
- **板块异动**: 558条/天 × 250交易日 = 139,500条/年
- **交易复盘记录**: 用户创建，数量不定
- **总计**: 约190,000条/年

### 数据特征
1. **时间序列数据为主** - 大部分数据按日期组织
2. **查询模式** - 主要按日期、股票代码查询
3. **写入频率** - 每日定时写入（收盘后）
4. **数据增长** - 线性增长，每年约19万条
5. **数据保留** - 需要长期保存历史数据

## 数据库方案对比

### 1. SQLite（当前使用）✅ 推荐用于开发/小规模

**优点**:
- ✅ 零配置，无需单独安装
- ✅ 单文件存储，易于备份和迁移
- ✅ 轻量级，适合中小型应用
- ✅ 支持SQL标准，SQLAlchemy完美支持
- ✅ 读写性能对于当前数据量足够

**缺点**:
- ❌ 并发写入性能有限（适合单用户或少量并发）
- ❌ 不支持多服务器部署
- ❌ 数据量过大时性能下降（建议<100GB）

**适用场景**:
- 个人使用
- 小团队使用
- 开发/测试环境
- 数据量<100万条

**建议**: 当前阶段**继续使用SQLite**，数据量增长后再迁移

---

### 2. PostgreSQL ✅ 推荐用于生产环境

**优点**:
- ✅ 功能强大，支持复杂查询
- ✅ 优秀的并发性能
- ✅ 支持JSON、数组等高级数据类型
- ✅ 丰富的索引类型（B-tree, GIN, GiST等）
- ✅ 支持时间序列扩展（TimescaleDB）
- ✅ 成熟稳定，生产环境广泛使用

**缺点**:
- ❌ 需要单独安装和配置
- ❌ 资源占用较大
- ❌ 学习曲线相对较陡

**适用场景**:
- 生产环境
- 多用户并发访问
- 需要复杂查询和分析
- 数据量>100万条

**迁移建议**: 当数据量增长或需要多用户访问时迁移

---

### 3. MySQL/MariaDB

**优点**:
- ✅ 成熟稳定，广泛使用
- ✅ 良好的并发性能
- ✅ 丰富的工具和生态

**缺点**:
- ❌ 对于时间序列数据不如PostgreSQL优化好
- ❌ JSON支持不如PostgreSQL完善

**适用场景**:
- 团队已有MySQL经验
- 需要与现有MySQL系统集成

---

### 4. TimescaleDB（PostgreSQL扩展）

**优点**:
- ✅ 专门优化时间序列数据
- ✅ 自动分区（按时间）
- ✅ 压缩和保留策略
- ✅ 查询性能优秀

**缺点**:
- ❌ 需要PostgreSQL作为基础
- ❌ 学习成本较高

**适用场景**:
- 大量时间序列数据（>100万条）
- 需要高性能时间序列查询
- 需要数据压缩和自动归档

---

### 5. InfluxDB

**优点**:
- ✅ 专门为时间序列数据设计
- ✅ 高性能写入和查询
- ✅ 自动数据保留策略

**缺点**:
- ❌ SQL支持有限（使用InfluxQL）
- ❌ 不适合关系型数据（如交易复盘记录）
- ❌ 学习曲线陡峭

**适用场景**:
- 纯时间序列数据
- 高频写入场景
- 不需要复杂关系查询

**不推荐**: 因为系统中有关系型数据（交易复盘记录）

---

## 推荐方案

### 阶段1：当前（数据量<50万条）
**使用SQLite**
- 简单易用
- 满足当前需求
- 零维护成本

### 阶段2：数据量增长（50万-500万条）
**迁移到PostgreSQL**
- 更好的并发性能
- 支持复杂查询
- 可扩展性强

### 阶段3：大量时间序列数据（>500万条）
**考虑TimescaleDB**
- 专门优化时间序列
- 自动分区和压缩
- 高性能查询

## 数据表设计建议

### 当前表结构（SQLite）
1. `trading_reviews` - 交易复盘记录
2. `sector_history` - 板块历史数据

### 建议新增表（如迁移到PostgreSQL）
3. `zt_pool_history` - 涨停股票池历史
4. `zbgc_pool_history` - 炸板股票池历史
5. `dtgc_pool_history` - 跌停股票池历史
6. `board_change_history` - 板块异动历史

### 索引建议
- 所有表的 `date` 字段建立索引
- 股票代码字段建立索引
- 板块名称字段建立索引
- 考虑复合索引：`(date, stock_code)`

## 迁移方案（如需要）

### SQLite → PostgreSQL迁移步骤

1. **安装PostgreSQL**
```bash
# macOS
brew install postgresql

# Ubuntu
sudo apt-get install postgresql
```

2. **创建数据库**
```sql
CREATE DATABASE trading_review;
```

3. **修改配置**
```python
# config.py
DATABASE_URL = 'postgresql://user:password@localhost/trading_review'
```

4. **使用SQLAlchemy迁移**
```python
# SQLAlchemy支持自动迁移，只需修改DATABASE_URL
```

5. **数据迁移脚本**
```python
# 使用pandas或SQLAlchemy迁移现有数据
```

## 可视化需求考虑

如果需要**数据可视化图表**，推荐：

### 最佳选择：PostgreSQL + TimescaleDB ⭐⭐⭐⭐⭐

**优势**:
- ✅ **时间序列优化** - 自动分区，查询性能优秀
- ✅ **强大的聚合函数** - 支持时间桶、移动平均等
- ✅ **与可视化工具兼容** - Grafana, Metabase, Superset等
- ✅ **实时查询** - 支持实时数据可视化

**可视化工具推荐**:
- **Grafana** - 专业时间序列可视化（强烈推荐）
- **Metabase** - 简单易用的开源BI工具
- **Apache Superset** - 功能强大的开源BI
- **Plotly Dash/Streamlit** - Python Web框架，可定制

**示例查询**:
```sql
-- 按日期聚合板块涨跌幅（适合折线图）
SELECT date, AVG(change_percent) as avg_change
FROM sector_history
WHERE date >= '2025-01-01'
GROUP BY date
ORDER BY date;

-- 板块排名（适合柱状图）
SELECT name, change_percent
FROM sector_history
WHERE date = '2025-11-17'
ORDER BY change_percent DESC
LIMIT 10;
```

### 当前阶段：SQLite + 优化 ⭐⭐⭐

如果继续使用SQLite进行可视化：
- ✅ 适合简单图表（折线图、柱状图）
- ✅ 数据量<50万条时性能足够
- ⚠️ 需要添加合适索引
- ⚠️ 复杂聚合查询性能有限

---

## 总结

**当前推荐**: 继续使用 **SQLite**，原因：
1. 数据量适中（年约19万条）
2. 单用户或小团队使用
3. 简单易维护
4. 性能足够

**如果需要可视化图表**: 推荐迁移到 **PostgreSQL + TimescaleDB**
1. 时间序列数据优化
2. 查询性能优秀
3. 与可视化工具兼容性好
4. 支持复杂聚合查询

**未来考虑**: 当出现以下情况时考虑迁移到 **PostgreSQL**：
1. 数据量>100万条
2. 需要多用户并发访问
3. 需要复杂查询和分析
4. 需要高可用性
5. **需要数据可视化图表** ⭐

