# stock_fund_flow_individual 接口返回结果分析

## 📊 接口调用结果

### ❌ 错误信息
```
ValueError: Length mismatch: Expected axis has 10 elements, new values have 7 elements
```

### ✅ 成功捕获的原始数据

**数据形状**: (5153, 10) - 5153行，10列

**实际返回的列名**:
1. `index` - 序号
2. `股票代码` - 股票代码
3. `股票简称` - 股票简称
4. `最新价` - 最新价
5. `涨跌幅` - 涨跌幅（百分比字符串，如 "151.12%"）
6. `换手率` - 换手率（百分比字符串，如 "74.04%"）
7. `流入资金(元)` - 流入资金（带单位，如 "7.60亿"）
8. `流出资金(元)` - 流出资金（带单位，如 "8.60亿"）
9. `净额(元)` - 净额（带单位，如 "-1.00亿"）
10. `成交额(元)` - 成交额（带单位，如 "16.31亿"）

**样本数据**:
```
index: 1, 2
股票代码: 688796, 300189
股票简称: '百奥赛图', '神农种业'
最新价: 67.0, 6.88
涨跌幅: '151.12%', '20.07%'
换手率: '74.04%', '51.11%'
流入资金(元): '7.60亿', '16.66亿'
流出资金(元): '8.60亿', '12.60亿'
净额(元): '-1.00亿', '4.07亿'
成交额(元): '16.31亿', '29.27亿'
```

## 🔍 问题分析

### 根本原因

1. **接口用途错误**: 
   - `stock_fund_flow_individual` 接口**不是用来获取单个股票数据的**
   - 它返回的是**所有股票的排行数据**（5153只股票）
   - 参数 `symbol` 应该是 `"即时"`、`"3日排行"`、`"5日排行"` 等，而不是股票代码

2. **列名设置错误**:
   - 当 `symbol != "即时"` 时，代码尝试设置7个列名
   - 但实际返回的数据有10列
   - 传入股票代码（如 "000001"）时，`symbol != "即时"`，所以走到了 else 分支

3. **代码中的错误使用**:
   ```python
   # 错误用法（当前代码）:
   df_fund = ak.stock_fund_flow_individual(symbol=stock_code)  # stock_code = "000001"
   
   # 正确用法应该是:
   df_fund = ak.stock_fund_flow_individual(symbol="即时")  # 获取所有股票的即时数据
   # 然后从结果中筛选出目标股票
   ```

### 源码分析

从 akshare 源码可以看到：

```python
def stock_fund_flow_individual(symbol: str = "即时") -> pd.DataFrame:
    """
    同花顺-数据中心-资金流向-个股资金流
    :param symbol: choice of {"即时", "3日排行", "5日排行", "10日排行", "20日排行"}
    """
    # ... 获取数据 ...
    
    if symbol == "即时":
        big_df.columns = [
            "序号", "股票代码", "股票简称", "最新价", "涨跌幅", 
            "换手率", "流入资金", "流出资金", "净额", "成交额",
        ]  # 10列
    else:
        big_df.columns = [
            "序号", "股票代码", "股票简称", "最新价", 
            "阶段涨跌幅", "连续换手率", "资金流入净额",
        ]  # 7列 - 但实际数据有10列，所以报错
```

## 💡 解决方案

### 方案1: 使用正确的接口调用方式（推荐）

修改 `StockFundFlowHistoryService.save_stock_fund_flow` 方法：

```python
# 获取所有股票的即时数据
df_fund = ak.stock_fund_flow_individual(symbol="即时")

# 筛选目标股票
df_stock = df_fund[df_fund['股票代码'] == stock_code]

if df_stock.empty:
    logger.warning(f"股票代码 {stock_code} 的资金流数据为空")
    return False

# 获取该股票的数据
latest_data = df_stock.iloc[0]
```

**优点**: 
- 使用正确的接口调用方式
- 可以获取到数据

**缺点**: 
- 需要获取所有股票数据，然后筛选，效率较低
- 如果股票不在排行中，可能获取不到数据

### 方案2: 使用替代接口（更推荐）

使用 `ak.stock_individual_fund_flow(stock=stock_code)` 接口，该接口：
- ✅ 专门用于获取单个股票的资金流数据
- ✅ 返回120天的历史数据
- ✅ 已在 `pages/8_个股表现.py` 中成功使用

## 📋 接口返回数据格式对比

| 接口 | 返回数据 | 列数 | 数据格式 | 用途 |
|------|----------|------|----------|------|
| `stock_fund_flow_individual(symbol="即时")` | 所有股票排行 | 10列 | 即时数据 | 获取所有股票的排行 |
| `stock_individual_fund_flow(stock="000001")` | 单个股票历史 | 13列 | 120天历史 | 获取单个股票的历史数据 |

## 🚀 建议

1. **立即修复**: 修改 `StockFundFlowHistoryService` 使用正确的接口
2. **推荐使用**: `stock_individual_fund_flow` 接口，更适合获取单个股票数据
3. **数据适配**: 注意字段名称和格式的差异，需要做映射和转换

